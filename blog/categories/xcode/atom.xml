<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xcode | 人生短短数十载]]></title>
  <link href="http://livv.github.io/blog/categories/xcode/atom.xml" rel="self"/>
  <link href="http://livv.github.io/"/>
  <updated>2014-12-13T14:42:35+08:00</updated>
  <id>http://livv.github.io/</id>
  <author>
    <name><![CDATA[vvlee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xcode 常用编译选项设置]]></title>
    <link href="http://livv.github.io/blog/2013/02/16/xcode-common-complie-option/"/>
    <updated>2013-02-16T11:39:00+08:00</updated>
    <id>http://livv.github.io/blog/2013/02/16/xcode-common-complie-option</id>
    <content type="html"><![CDATA[<p>用标准库连接</p>

<p>LINK_WITH_STANDARD_LIBRARIES = YES</p>

<p>如果激活此设置，那么编译器在链接过程中会自动使用通过标准库的链接器。</p>

<p>Info.plist 输出编码</p>

<p>INFOPLIST_OUTPUT_FORMAT = binary</p>

<p>指定Info.plist文件的输出编码（默认情况下，输出与输入的编码保持不变），这个输出编码能指定“binary”或者“XML”。</p>

<p>生成调试符号</p>

<p>GCC_GENERATE_DEBUGGING_SYMBOLS = NO</p>

<p>当启用的时候，详情等级能够通过build的&#8217;Level of Debug Symbols&#8217;设置去控制。</p>

<p>隐藏内联方法</p>

<p>GCC_INLINES_ARE_PRIVATE_EXTERN = YES</p>

<p>Objective－C GC</p>

<p>GCC_ENABLE_OBJC_GC = Unsupported</p>

<p>优化级别</p>

<p>GCC_OPTIMIZATION_LEVEL = Fastest, Smallest   [-OS]</p>

<ul>
<li>None: 不做优化使用这个设置，编译器的目标是减少编译成本，使调试产生预期的结果。</li>
<li>Fast：优化编译将为大函数占用更多的时间和内存使用这个设置，编译器将尝试减少代码的大小和执行时间，不进行任何优化，需要大量编译时间。</li>
<li>Faster：编译器执行几乎所有支持的优化，它不考虑空间和速度之间的平衡与“Fast”设置相比，该设置会增加编译时间和生成代码的性能。编译器不进行循环展开、内联函数和寄存器变量的重命名。</li>
<li>Fastest：开启“Faster”支持的所有的优化，同时也开启内联函数和寄存器变量的重命名选项</li>
<li>Fastest,smallest：优化代码大小这个设置启用“Faster”所有的优化，一般不增加代码大小，它还执行旨在减小代码大小的进一步优化。</li>
</ul>


<p>C语言方言</p>

<p>GCC_C_LANGUAGE_STANDARD = C89</p>

<p>警告</p>

<p>检查Switch语句</p>

<p>GCC_WARN_CHECK_SWITCH_STATEMENTS = YES</p>

<p>隐藏局部变量</p>

<p>GCC_WARN_SHADOW = YES</p>

<p>隐式转换成32位的类型</p>

<p>GCC_WARN_64_TO_32_BIT_CONVERSION = YES</p>

<p>未完成的Objective－C协议</p>

<p>GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL = YES</p>

<p>抑制所有的警告</p>

<p>GCC_WARN_INHIBIT_ALL_WARNINGS = NO</p>

<p>初始化时没有完整的括号</p>

<p>GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED = YES</p>

<p>例子（a没有完全的括号，b有）：</p>

<pre><code>int a[ 2 ][ 2 ] = { 0, 1, 2, 3 };   
int b[ 2 ][ 2 ] = { { 0, 1 }, { 2, 3 } }; 
</code></pre>

<p>不匹配的返回类型</p>

<p>GCC_WARN_ABOUT_RETURN_TYPE = YES</p>

<p>缺少括号</p>

<p>GCC_WARN_MISSING_PARENTHESES = YES</p>

<p>例子：</p>

<pre><code>{  
    if( a )  
        if( b )  
            foo();  
        else  
            bar();  
} 
</code></pre>

<pre><code>{  
    if( a )  
    {  
        if( b )  
            foo();  
        else  
            bar();  
    }  
} 
</code></pre>

<p>在结构体初始化时缺少字段</p>

<p>GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS = YES</p>

<p>缺少函数原型</p>

<p>GCC_WARN_ABOUT_MISSING_PROTOTYPES = YES</p>

<p>在文件结尾缺少新行</p>

<p>GCC_WARN_ABOUT_MISSING_NEWLINE = YES</p>

<p>选择了多个定义的类型(@Selector)</p>

<p>GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR = NO</p>

<p>严格的Selector匹配</p>

<p>GCC_WARN_STRICT_SELECTOR_MATCH = YES</p>

<p>把缺少函数原型当作错误</p>

<p>GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS = YES</p>

<p>把所有的警告当作错误</p>

<p>GCC_TREAT_WARNINGS_AS_ERRORS = YES</p>

<p>未定义的Selector</p>

<p>GCC_WARN_UNDECLARED_SELECTOR = YES</p>

<p>未初始化的自动变量</p>

<p>GCC_WARN_UNINITIALIZED_AUTOS = YES</p>

<p>未知的Pragma指令</p>

<p>GCC_WARN_UNKNOWN_PRAGMAS = YES</p>

<p>未使用的函数</p>

<p>GCC_WARN_UNUSED_FUNCTION = YES</p>

<p>未使用的标签</p>

<p>GCC_WARN_UNUSED_LABEL = YES</p>

<p>未使用的参数</p>

<p>GCC_WARN_UNUSED_PARAMETER = YES</p>

<p>未使用的值</p>

<p>GCC_WARN_UNUSED_VALUE = YES</p>

<p>当一个语句计算的结果显式的未使用的时候发出警告</p>

<p>未使用的变量</p>

<p>GCC_WARN_UNUSED_VARIABLE = YES</p>

<p>警告－所有过时的函数</p>

<p>GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS = YES</p>

<p>offsetof宏未定义使用的警告</p>

<p>GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO = YES</p>
]]></content>
  </entry>
  
</feed>
